<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#000000"><link rel="manifest" href="/cofue-sensor-tests/manifest.json"><link rel="shortcut icon" href="/cofue-sensor-tests/favicon.ico"><title>cofuente.io</title><link href="/cofue-sensor-tests/static/css/main.08c053c7.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to even see this page.</noscript><script type="module">const slot = window["__sensor__"] = Symbol("__sensor__")
let orientation = {}

Object.defineProperty(orientation, "angle", {
  get: () => { return (window.orientation || 0) }
})

const defineProperties = (target, descriptions) => {
  console.log('slot:', slot, typeof slot)
  for (const property in descriptions) {
    Object.defineProperty(target, property, {
      configurable: true,
      value: descriptions[property]
    })
  }
}
const defineReadonlyProperties = (target, slot, descriptions) => {
  const propertyBag = target[slot] || (target[slot] = new WeakMap)
  for (const property in descriptions) {
    propertyBag[property] = descriptions[property]
    Object.defineProperty(target, property, {
      get: () => propertyBag[property]
    })
  }
}
const defineOnEventListener = (target, name) => Object.defineProperty(target, `on${name}`, {
  enumerable: true,
  configurable: false,
  writable: true,
  value: null
})

export const EventTargetMixin = (superclass, ...eventNames) => class extends superclass {
  constructor(...args) {
    super(args)
    const eventTarget = document.createDocumentFragment()

    this.addEventListener = (type, ...args) => {
      return eventTarget.addEventListener(type, ...args)
    }

    this.removeEventListener = (...args) => {
      return eventTarget.removeEventListener(...args)
    }

    this.dispatchEvent = (event) => {
      defineProperties(event, { currentTarget: this })
      if (!event.target) {
        defineProperties(event, { target: this })
      }

      const methodName = `on${event.type}`
      if (typeof this[methodName] == "function") {
        this[methodName](event)
      }

      const retValue = eventTarget.dispatchEvent(event)

      if (retValue && this.parentNode) {
        this.parentNode.dispatchEvent(event)
      }

      defineProperties(event, { currentTarget: null, target: null })

      return retValue
    }
  }
}
export class EventTarget extends EventTargetMixin(Object) { }

const SensorState = {
  ERROR: 0,
  IDLE: 1,
  ACTIVATING: 2,
  ACTIVE: 3,
}

class SensorErrorEvent extends Event {
  constructor(type, errorEventInitDict) {
    super(type, errorEventInitDict)

    if (!errorEventInitDict || !errorEventInitDict.error instanceof DOMException) {
      throw TypeError(
        "Failed to construct 'SensorErrorEvent':" +
        "2nd argument much contain 'error' property"
      )
    }

    Object.defineProperty(this, "error", {
      configurable: false,
      writable: false,
      value: errorEventInitDict.error
    })
  }
}

export class Sensor extends EventTarget {
  constructor(options) {
    super()
    this[slot] = new WeakMap

    defineOnEventListener(this, "reading")
    defineOnEventListener(this, "activate")
    defineOnEventListener(this, "error")

    defineReadonlyProperties(this, slot, {
      activated: false,
      hasReading: false,
      timestamp: null
    })

    this[slot].setState = (value) => {
      switch (value) {
        case SensorState.ERROR: {
          let error = new SensorErrorEvent("error", {
            error: new DOMException("Could not connect to a sensor")
          })
          this.dispatchEvent(error)

          this.stop() // Moves to IDLE state.
          break
        }
        case SensorState.IDLE: {
          this[slot].activated = false
          this[slot].hasReading = false
          this[slot].timestamp = null
          break
        }
        case SensorState.ACTIVATING: {
          break
        }
        case SensorState.ACTIVE: {
          let activate = new Event("activate")
          this[slot].activated = true
          this.dispatchEvent(activate)
          break
        }
      }
    }

    this[slot].frequency = null

    if (window && window.parent != window.top) {
      throw new DOMException("Only instantiable in a top-level browsing context", "SecurityError")
    }

    if (options && typeof (options.frequency) == "number") {
      if (options.frequency > 60) {
        this.frequency = options.frequency
      }
    }
  }

  start() { }
  stop() { }
}

const DeviceOrientationMixin = (superclass, ...eventNames) => class extends superclass {
  constructor(...args) {
    super(args)

    for (const eventName of eventNames) {
      if (`on${eventName}` in window) {
        this[slot].eventName = eventName
        break
      }
    }
  }

  start() {
    super.start()
    this[slot].setState(SensorState.ACTIVATING)
    window.addEventListener(this[slot].eventName, this[slot].handleEvent, { capture: true })
  }

  stop() {
    super.stop()
    this[slot].setState(SensorState.IDLE)
    window.removeEventListener(this[slot].eventName, this[slot].handleEvent, { capture: true })
  }
}

const toQuaternionFromEuler = (alpha, beta, gamma) => {
  const degToRad = Math.PI / 180

  const x = (beta || 0) * degToRad
  const y = (gamma || 0) * degToRad
  const z = (alpha || 0) * degToRad

  const cZ = Math.cos(z * 0.5)
  const sZ = Math.sin(z * 0.5)
  const cY = Math.cos(y * 0.5)
  const sY = Math.sin(y * 0.5)
  const cX = Math.cos(x * 0.5)
  const sX = Math.sin(x * 0.5)

  const qx = sX * cY * cZ - cX * sY * sZ
  const qy = cX * sY * cZ + sX * cY * sZ
  const qz = cX * cY * sZ + sX * sY * cZ
  const qw = cX * cY * cZ - sX * sY * sZ

  return [qx, qy, qz, qw]
}

const rotateQuaternionByAxisAngle = (quat, axis, angle) => {
  const sHalfAngle = Math.sin(angle / 2)
  const cHalfAngle = Math.cos(angle / 2)

  const transformQuat = [
    axis[0] * sHalfAngle,
    axis[1] * sHalfAngle,
    axis[2] * sHalfAngle,
    cHalfAngle
  ]

  const multiplyQuaternion = (a, b) => {
    const qx = a[0] * b[3] + a[3] * b[0] + a[1] * b[2] - a[2] * b[1]
    const qy = a[1] * b[3] + a[3] * b[1] + a[2] * b[0] - a[0] * b[2]
    const qz = a[2] * b[3] + a[3] * b[2] + a[0] * b[1] - a[1] * b[0]
    const qw = a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2]

    return [qx, qy, qz, qw]
  }

  const normalizeQuaternion = (quat) => {
    const length = Math.sqrt(quat[0] ** 2 + quat[1] ** 2 + quat[2] ** 2 + quat[3] ** 2)
    if (length === 0) {
      return [0, 0, 0, 1]
    }

    return quat.map(v => v / length)
  }

  return normalizeQuaternion(multiplyQuaternion(quat, transformQuat))
}

const toMat4FromQuat = (mat, q) => {
  const typed = mat instanceof Float32Array || mat instanceof Float64Array

  if (typed && mat.length >= 16) {
    mat[0] = 1 - 2 * (q[1] ** 2 + q[2] ** 2)
    mat[1] = 2 * (q[0] * q[1] - q[2] * q[3])
    mat[2] = 2 * (q[0] * q[2] + q[1] * q[3])
    mat[3] = 0

    mat[4] = 2 * (q[0] * q[1] + q[2] * q[3])
    mat[5] = 1 - 2 * (q[0] ** 2 + q[2] ** 2)
    mat[6] = 2 * (q[1] * q[2] - q[0] * q[3])
    mat[7] = 0

    mat[8] = 2 * (q[0] * q[2] - q[1] * q[3])
    mat[9] = 2 * (q[1] * q[2] + q[0] * q[3])
    mat[10] = 1 - 2 * (q[0] ** 2 + q[1] ** 2)
    mat[11] = 0

    mat[12] = 0
    mat[13] = 0
    mat[14] = 0
    mat[15] = 1
  }

  return mat
}

const worldToScreen = (quaternion) => !quaternion ? null :
  rotateQuaternionByAxisAngle(
    quaternion,
    [0, 0, 1],
    - orientation.angle * Math.PI / 180
  )

export const AbsoluteOrientationSensor = window.AbsoluteOrientationSensor ||
  class AbsoluteOrientationSensor extends DeviceOrientationMixin(
    Sensor, "deviceorientationabsolute", "deviceorientation") {
    constructor(options = {}) {
      super(options)

      switch (options.coordinateSystem || 'world') {
        case 'screen':
          Object.defineProperty(this, "quaternion", {
            get: () => worldToScreen(this[slot].quaternion)
          })
          break
        case 'world':
        default:
          Object.defineProperty(this, "quaternion", {
            get: () => this[slot].quaternion
          })
      }

      this[slot].handleEvent = event => {
        // If absolute is set, or webkitCompassHeading exists,
        // absolute values should be available.
        const isAbsolute = event.absolute === true || "webkitCompassHeading" in event
        const hasValue = event.alpha !== null || event.webkitCompassHeading !== undefined

        if (!isAbsolute || !hasValue) {
          // Spec: If an implementation can never provide absolute
          // orientation information, the event should be fired with
          // the alpha, beta and gamma attributes set to null.
          this[slot].setState(SensorState.ERROR)
          return
        }

        if (!this[slot].activated) {
          this[slot].setState(SensorState.ACTIVE)
        }

        this[slot].hasReading = true
        this[slot].timestamp = performance.now()

        const heading = event.webkitCompassHeading != null ? 360 - event.webkitCompassHeading : event.alpha

        this[slot].quaternion = toQuaternionFromEuler(
          heading,
          event.beta,
          event.gamma
        )

        this.dispatchEvent(new Event("reading"))
      }
    }

    stop() {
      super.stop()
      this[slot].quaternion = null
    }

    populateMatrix(mat) {
      toMat4FromQuat(mat, this.quaternion)
    }
  }
  
      let sensor
      const initSensor = () => {
        const options = { frequency: 60, coordinateSystem: null }
          console.log('options passed into AOS constructor:', JSON.stringify(options))
          sensor = new AbsoluteOrientationSensor(options)
          // sensor is NOT an array but an object that has onreading, onactivate and onerror keys
          sensor.onreading = () => {
          // console.log('within onreading:', 'sensor:', JSON.stringify(sensor))
          // quaternion IS an array of numbers corresponding to x, y, z, w
          console.log('within onreading:', 'quaternion:', JSON.stringify(sensor.quaternion))
          }
        sensor.onerror = (event) => {
          if (event.error.name == 'NotReadableError') {
            console.log("Sensor is not available.")
          }
        }
        sensor.start()
      }
      initSensor()</script><div id="root"></div><script>!function(l){function e(e){for(var r,t,n=e[0],o=e[1],u=e[2],f=0,i=[];f<n.length;f++)t=n[f],c[t]&&i.push(c[t][0]),c[t]=0;for(r in o)Object.prototype.hasOwnProperty.call(o,r)&&(l[r]=o[r]);for(s&&s(e);i.length;)i.shift()();return p.push.apply(p,u||[]),a()}function a(){for(var e,r=0;r<p.length;r++){for(var t=p[r],n=!0,o=1;o<t.length;o++){var u=t[o];0!==c[u]&&(n=!1)}n&&(p.splice(r--,1),e=f(f.s=t[0]))}return e}var t={},c={1:0},p=[];function f(e){if(t[e])return t[e].exports;var r=t[e]={i:e,l:!1,exports:{}};return l[e].call(r.exports,r,r.exports,f),r.l=!0,r.exports}f.m=l,f.c=t,f.d=function(e,r,t){f.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:t})},f.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},f.t=function(r,e){if(1&e&&(r=f(r)),8&e)return r;if(4&e&&"object"==typeof r&&r&&r.__esModule)return r;var t=Object.create(null);if(f.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:r}),2&e&&"string"!=typeof r)for(var n in r)f.d(t,n,function(e){return r[e]}.bind(null,n));return t},f.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return f.d(r,"a",r),r},f.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},f.p="/cofue-sensor-tests/";var r=window.webpackJsonp=window.webpackJsonp||[],n=r.push.bind(r);r.push=e,r=r.slice();for(var o=0;o<r.length;o++)e(r[o]);var s=n;a()}([])</script><script src="/cofue-sensor-tests/static/js/2.695f8dd0.chunk.js"></script><script src="/cofue-sensor-tests/static/js/main.ded138b2.chunk.js"></script></body></html>